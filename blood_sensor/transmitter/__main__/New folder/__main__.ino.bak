#include "ssd1306h.h"
#include "MAX30102.h"
#include "Pulse.h"
#include <avr/pgmspace.h>
#include <EEPROM.h>
#include <avr/sleep.h>

#ifndef cbi
#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
#endif
#ifndef sbi
#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
#endif


SSD1306 oled;
MAX30102 sensor;
Pulse pulseIR;
Pulse pulseRed;
MAFilter bpm;

#define LED LED_BUILTIN
#define BUTTON 3
#define OPTIONS 7

//spo2_table is approximated as  -45.060*ratioAverage* ratioAverage + 30.354 *ratioAverage + 94.845 ;
const uint8_t spo2_table[184] PROGMEM = { 95, 95, 95, 96, 96, 96, 97, 97, 97, 97, 97, 98, 98, 98, 98, 98, 99, 99, 99, 99,
                                          99, 99, 99, 99, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
                                          100, 100, 100, 100, 99, 99, 99, 99, 99, 99, 99, 99, 98, 98, 98, 98, 98, 98, 97, 97,
                                          97, 97, 96, 96, 96, 96, 95, 95, 95, 94, 94, 94, 93, 93, 93, 92, 92, 92, 91, 91,
                                          90, 90, 89, 89, 89, 88, 88, 87, 87, 86, 86, 85, 85, 84, 84, 83, 82, 82, 81, 81,
                                          80, 80, 79, 78, 78, 77, 76, 76, 75, 74, 74, 73, 72, 72, 71, 70, 69, 69, 68, 67,
                                          66, 66, 65, 64, 63, 62, 62, 61, 60, 59, 58, 57, 56, 56, 55, 54, 53, 52, 51, 50,
                                          49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 31, 30, 29,
                                          28, 27, 26, 25, 23, 22, 21, 20, 19, 17, 16, 15, 14, 12, 11, 10, 9, 7, 6, 5,
                                          3, 2, 1 };


int beatAvg = 0;
int SPO2 = 0, SPO2f = 0;
int sys, dias;
int state;

int voltage;
bool filter_for_graph = false;
bool draw_Red = false;
uint8_t pcflag = 0;
uint8_t istate = 0;
uint8_t sleep_counter = 0;
long lastBeat = 0;     //Time of the last beat
long displaytime = 0;  //Time of the last display update
bool led_on = false;

void draw_oled(int msg);
void button();
void checkbutton();
void go_sleep();
int getVCC();
void print_digit(int x, int y, long val, char c = ' ', uint8_t field = 3, const int BIG = 2);


void setup() {
  Serial.begin(115200);

  pinMode(LED, OUTPUT);
  pinMode(BUTTON, INPUT);
  // filter_for_graph = EEPROM.read(OPTIONS);
  draw_Red = EEPROM.read(OPTIONS + 1);
  oled.init();
  oled.fill(0x00);
  draw_oled(3);
  delay(2000);
  if (!sensor.begin()) {
    draw_oled(0);
    // delay(2000);
    while (1)
      ;
  }
  sensor.setup();
  attachInterrupt(digitalPinToInterrupt(BUTTON), button, FALLING);
}


void loop() {
  Serial.println(pcflag);

  sensor.check();
  long now = millis();  //start time of this cycle
  if (!sensor.available()) return;
  uint32_t irValue = sensor.getIR();
  uint32_t redValue = sensor.getRed();
  sensor.nextSample();
  if (irValue < 5000) {
    // voltage = getVCC();
    // checkbutton();
    draw_oled(sleep_counter <= 50 ? 1 : 4);  // finger not down message
    delay(200);
    ++sleep_counter;
    if (sleep_counter > 100) {
      go_sleep();
      sleep_counter = 0;
    }
  } else {
    sleep_counter = 0;
    int16_t IR_signal, Red_signal;
    bool beatRed, beatIR;
    if (!filter_for_graph) {
      IR_signal = pulseIR.dc_filter(irValue);
      Red_signal = pulseRed.dc_filter(redValue);
      beatRed = pulseRed.isBeat(pulseRed.ma_filter(Red_signal));
      beatIR = pulseIR.isBeat(pulseIR.ma_filter(IR_signal));
    } else {
      IR_signal = pulseIR.ma_filter(pulseIR.dc_filter(irValue));
      Red_signal = pulseRed.ma_filter(pulseRed.dc_filter(redValue));
      beatRed = pulseRed.isBeat(Red_signal);
      beatIR = pulseIR.isBeat(IR_signal);
    }
    // check IR or Red for heartbeat
    if (draw_Red ? beatRed : beatIR) {
      long btpm = 60000 / (now - lastBeat);
      if (btpm > 0 && btpm < 200) beatAvg = bpm.filter((int16_t)btpm);
      lastBeat = now;
      digitalWrite(LED, HIGH);
      led_on = true;
      // compute SpO2 ratio
      long numerator = (pulseRed.avgAC() * pulseIR.avgDC()) / 256;
      long denominator = (pulseRed.avgDC() * pulseIR.avgAC()) / 256;
      int RX100 = (denominator > 0) ? (numerator * 100) / denominator : 999;
      // using formula
      SPO2f = (10400 - RX100 * 17 + 50) / 100;
      // from table
      if ((RX100 >= 0) && (RX100 < 184))
        SPO2 = pgm_read_byte_near(&spo2_table[RX100]);
    }
    // update display every 50 ms if fingerdown
    if (now - displaytime > 50) {
      displaytime = now;
      // wave.scale();
      draw_oled(2);
    }
  }
  // flash led for 25 ms
  if (led_on && (now - lastBeat) > 25) {
    digitalWrite(LED, LOW);
    led_on = false;
  }
}


void draw_oled(int msg) {
  oled.firstPage();
  do {
    switch (msg) {
      case 0:
        state = 0;
        oled.drawStr(10, 0, F("Device error"), 1);

        break;
      case 1:
        state = 1;
        oled.drawStr(33, 8, F("Place Your"), 1);
        oled.drawStr(45, 18, F("Finger"), 1);

        break;
      case 2:
        state = 2;
        oled.drawStr(0, 4, F("Pulse"), 1);
        print_digit(45, 4, beatAvg, ' ', 3, 1);
        // oled.drawStr(43, 15, F("bpm"), 1);

        oled.drawStr(0, 20, F("% SpO2"), 1);
        print_digit(45, 20, SPO2, ' ', 3, 1);
        // oled.drawStr(120, 15, F("%"), 1);

        oled.drawStr(85, 4, F("Sys"), 1);
        print_digit(110, 4, sys, ' ', 3, 1);

        oled.drawStr(85, 20, F("Dia"), 1);
        print_digit(110, 20, dias, ' ', 3, 1);

        break;
      case 3:
        state = 3;
        oled.drawStr(33, 0, F("Pulse"), 2);
        oled.drawStr(17, 15, F("Oximeter"), 2);

        break;
      case 4:
        state = 4;
        oled.drawStr(28, 12, F("OFF IN"), 1);
        oled.drawChar(76, 12, 10 - sleep_counter / 10 + '0');
        oled.drawChar(82, 12, 's');

        break;
      case 5:
        state = 5;
        // Wire.beginTransmission(0x50);
        // Wire.onReceive(receiveEvent);

        oled.drawStr(0, 0, F("Blood Pressure"), 1);
        print_digit(75, 0, sys);
        oled.drawStr(0, 15, F("Sys"), 1);
        oled.drawStr(0, 22, F("Dias"), 1);
        print_digit(75, 15, dias);

        break;
    }
  } while (oled.nextPage());
}

void button() {
  pcflag = 1;
}

// void checkbutton() {
//   if (pcflag && !digitalRead(BUTTON)) {
//     istate = (istate + 1) % 4;
//     // filter_for_graph = istate & 0x01;
//     draw_Red = istate & 0x02;
//     // EEPROM.write(OPTIONS, filter_for_graph);
//     EEPROM.write(OPTIONS + 1, draw_Red);
//   }
//   pcflag = 0;
// }

void display_5() {
  if (pcflag && digitalRead(BUTTON)) {
    draw_oled(5);
    delay(1100);
  }
  pcflag = 0;
}

void go_sleep() {
  oled.fill(0);
  oled.off();
  delay(10);
  sensor.off();
  delay(10);
  cbi(ADCSRA, ADEN);  // disable adc
  delay(10);
  pinMode(0, INPUT);
  pinMode(2, INPUT);
  set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  sleep_mode();  // sleep until button press
  // cause reset
  setup();
}

// int getVCC() {
// //reads internal 1V1 reference against VCC
// #if defined(__AVR_ATmega1284P__)
//   ADMUX = _BV(REFS0) | _BV(MUX4) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);  // For ATmega1284
// #else
//   ADMUX = _BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);  // For ATmega328
// #endif
//   delay(2);             // Wait for Vref to settle
//   ADCSRA |= _BV(ADSC);  // Convert
//   while (bit_is_set(ADCSRA, ADSC))
//     ;
//   uint8_t low = ADCL;
//   unsigned int val = (ADCH << 8) | low;
//   //discard previous result
//   ADCSRA |= _BV(ADSC);  // Convert
//   while (bit_is_set(ADCSRA, ADSC))
//     ;
//   low = ADCL;
//   val = (ADCH << 8) | low;

//   return (((long)1024 * 1100) / val) / 100;
// }

void print_digit(int x, int y, long val, char c = ' ', uint8_t field = 3, const int BIG = 2) {
  uint8_t ff = field;
  do {
    char ch = (val != 0) ? val % 10 + '0' : c;
    oled.drawChar(x + BIG * (ff - 1) * 6, y, ch, BIG);
    val = val / 10;
    --ff;
  } while (ff > 0);
}
